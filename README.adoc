= Sample Server-Sent Events Demo

Provides a use-case example of using Server-Sent Events (SSE) as part of an
application's communication architecture.

== Comparing SSE and WebSockets

Server-Sent Events are built on the same protocols as other REST APIs and
widely supported by existing infrastructures. Another similar technology (and more
popular) are WebSockets providing very similar focus, but a more robust set of
capabilities.

Comparing these two technologies, we compare the facts between the two technologies
and explain why SSE are used:

|===
| | SSE | WebSockets

| Protocol | HTTP | WebSockets
| Data Flow | Server to Client | Bi-Directional
| Implementation | Like REST | Special Case
| Pros a| Easy to Setup

Extends existing protocols

Supported by any infrastructure that support long-lived connections
a| Bi-Directional messaging

Supports Structured data packets
| Cons a| Uni-directional

Text-only streaming
a| Requires additional modules

Needs developer to support incoming data responses from Clients
|===

=== Use Cases

SSE:: Push Notifications, Status Updates, pair with existing REST APIs
WebSockets:: Real-Time Chat / Gaming applications, IoT devices

== Demo Application Structure

The Demo Application has 4 components that handle the event messaging:

Redis:: The message broker broadcasting messages between the "message creator" and
the "message consumer". Other PubSub technologies can also be used, like AMQP or MQTT.
Redis is chosen for it's popularity and simplicity.
Generator:: Sample application creating messages which will be consumed by the Server.
Server:: Sample API Server consuming messaged by the Generator and passing them onto any
client subscribing to these messages.
UI:: Sample Web Application that connects to the SSE Endpoint and displays the messages
on a Web Frontend.

NOTE: Should be noted the *Generator* and *Server* applications may be the same
application, but a PubSub Broker would still be used to support cross-threading or
cross-process communications, allowing for horizontal scaling.

=== Data Flow

The data flow around this architecture is a linear pattern as all communication channels
follow an Event-Driven pattern, one message triggering another message.

[graphviz]
--------------
digraph G {
  node [ style = filled, color = lightgrey, overlap = scalexy ];
  Redis [ style = filled, color = darkred, fontcolor = white ];
  UI [ shape = box ]
  subgraph cluster_service {
    label="API Service"
    Generator;
    Server;
  }
  Generator -> Redis [style=dashed, label=pub]
  Redis -> Server [style=dashed, label=sub]
  Server -> UI [ label=SSE ]
}
--------------

The big difference when applying this in production is the need to scale. Since all
downstream clients will need to an API instance, all instances of the API Service must
receive the same message for downstream applications.

Reflecting the diagram to support this scenario would look like:

[graphviz]
--------------
digraph G {
  node [ style = filled, color = lightgrey, overlap = scalexy ];
  Redis [ style = filled, color = darkred, fontcolor = white ];
  UI [ shape = box ]
  subgraph cluster_service1 {
    label="API Service A"
    Generator_A;
    Server_A;
  }
  subgraph cluster_service2 {
    label="API Service B"
    Generator_B;
    Server_B;
  }
  Generator_A -> Redis [style=dashed, label=pub]
  Redis -> Server_A [style=dashed, label=sub]
  Redis -> Server_B [style=dashed, label=sub]
  Server_B -> UI [ label=SSE ]
}
--------------
